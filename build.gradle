buildscript {
    dependencies {
        classpath 'org.kohsuke:github-api:1.313'
    }
}

plugins {
    id 'fabric-loom' version '1.2-SNAPSHOT'
    id 'maven-publish'
    id "org.ajoberstar.grgit" version "3.1.0"
    id 'java-library'
    id "com.matthewprenger.cursegradle" version "1.4.0"
}

repositories {
    maven {
        name = "TerraformersMC"
        url = "https://maven.terraformersmc.com/releases"
    }
    maven { url 'https://dl.cloudsmith.io/public/geckolib3/geckolib/maven/' }
}

version = properties.mod_version

import org.apache.commons.codec.digest.DigestUtils

def getSubprojectVersion(project) {
    // Get the version from the gradle.properties file
    def version = project.rootProject.properties["mod_version"]

    if (!version) {
        throw new NullPointerException("Could not find version for " + project.name)
    }

    if (grgit == null) {
        return version + "+nogit"
    }

    def latestCommits = grgit.log(paths: [project.name], maxCommits: 1)

    if (latestCommits.isEmpty()) {
        return version + "+uncommited"
    }

    return version + "+" + latestCommits.get(0).id.substring(0, 8) + DigestUtils.sha256Hex(project.rootProject.minecraft_version).substring(0, 2)
}

def moduleDependencies(project, List<String> depNames) {
    def deps = depNames.iterator().collect { project.dependencies.project(path: ":$it", configuration: 'namedElements') }

    project.dependencies {
        deps.each {
            api it
        }
    }

    // As we manually handle the maven artifacts, we need to also manually specify the deps.
    project.publishing {
        publications {
            mavenJava(MavenPublication) {
                pom.withXml {
                    def depsNode = asNode().appendNode("dependencies")
                    deps.each {
                        def depNode = depsNode.appendNode("dependency")
                        depNode.appendNode("groupId", it.group)
                        depNode.appendNode("artifactId", it.name)
                        depNode.appendNode("version", it.version)
                        depNode.appendNode("scope", "compile")
                    }
                }
            }
        }
    }
}

allprojects {
    repositories {
        maven {
            url = "https://www.cursemaven.com"
        }
        maven { url 'https://dl.cloudsmith.io/public/geckolib3/geckolib/maven/' }
    }


    apply plugin: "fabric-loom"
    apply plugin: "maven-publish"
    apply plugin: "com.matthewprenger.cursegradle"

    tasks.withType(JavaCompile).configureEach {
        it.options.release = 17
    }

    group = rootProject.maven_group

    java {
        // Must be added before the split source sets are setup.
        withSourcesJar()
    }

    loom {
        runtimeOnlyLog4j = true
    }

    allprojects.each { p ->
        if (project.name == "deprecated") return

        loom.mods.register(p.name) {
            sourceSet p.sourceSets.main
        }
    }

    dependencies {
        minecraft "com.mojang:minecraft:${rootProject.minecraft_version}"
        mappings "net.fabricmc:yarn:${rootProject.yarn_mappings}:v2"
        modApi "net.fabricmc:fabric-loader:${rootProject.loader_version}"

        modImplementation "net.fabricmc.fabric-api:fabric-api:${rootProject.fabric_version}"
    }

    tasks.withType(ProcessResources).configureEach {
        inputs.property "version", project.version

        filesMatching("fabric.mod.json") {
            expand "version": project.version
        }
    }

    tasks.withType(AbstractArchiveTask) {
        preserveFileTimestamps = false
        reproducibleFileOrder = true
    }

    // Run this task after updating minecraft to regenerate any required resources
    task generateResources {
        group = "fabric"
    }

    [jar, sourcesJar].each {
        it.from(rootProject.file("LICENSE")) {
            rename { "${it}-${project.archivesBaseName}"}
        }
    }

    task validateMixinNames(type: net.fabricmc.loom.task.ValidateMixinNameTask) {
        source(sourceSets.main.output)
    }
}

subprojects {
    javadoc.enabled = false
}

task licenseFormatAll
subprojects { p -> licenseFormatAll.dependsOn("${p.path}:licenseFormat") }
subprojects.each { remapJar.dependsOn("${it.path}:remapJar") }

def devOnlyModules = [
        ""
]

dependencies {
    modImplementation "com.terraformersmc:modmenu:5.0.2"
    include modImplementation('software.bernie.geckolib:geckolib-fabric-1.19.3:4.0.3')

    afterEvaluate {
        subprojects.each {
            api project(path: "${it.path}", configuration: "namedElements")
        }
    }
}

remapJar {
    afterEvaluate {
        subprojects.each {
            if (it.name in devOnlyModules || it.name == "deprecated") return

            // Include the signed or none signed jar from the sub project.
            nestedJars.from project("${it.path}").tasks.getByName("remapJar")
        }
    }
}